---
title: Sidedness
---

# 游戏端

## 引言

在 Minecraft 中，游戏由两**端**构成——`client`（客户端）以及 `server`（服务端）。此两端还能进一步细分，根据其内差异，分为 `physical`（实体）以及 `logical`（逻辑）两个层面。

- `实体客户端`：当你启动 Minecraft 时，该程序也会同步启动。游戏的视觉效果、交互逻辑，所有的线程与处理，皆涵括其中。
- `实体服务端`：亦被称为 `完全服务端`（Dedicated Server），该程序会在可执行服务端启动时随之启动，所涵括的程序不会以可操作的 GUI 显示给玩家。
- `逻辑客户端`：指的是任何发生于 `客户端线程`（Client Thread）内的事物。它的主要职责为接受外界的输入信息（例如玩家操作），再将信息发送给 `服务端线程`（Server Thread）。同时，它还会相对应地从 `服务端线程` 取回信息，将信息送回给客户端线程，以供客户端渲染。
- `逻辑服务端`：指的是任何发生于 `服务端线程`内的事物。无论是 `实体客户端` 还是 `实体服务端`，内部都有服务端线程。这一线程主要司职管理怪物生成、天气、物品栏以及生命值等诸多要素。

## `@Mod`

`@Mod` 注解的参数有 `clientSideOnly`（仅客户端） 以及 `serverSideOnly`（仅服务端），具体区别不言自明。

如果你想将自己的模组设计为**单实体端**模组，使用这两个参数乃是最优选择。因为它们在模组加载的极早期便已生效。

但是，通过这种方法实现的单端模组不会显示在魔族列表中，如果你不能接受这一点，那你可以尝试一下下方介绍的另一种方法。

## `@SideOnly`

该注解可以作用于类、字段、方法以及构造函数上，Forge 会在加载加载模组时，在特定的**实体端**上**剔除**这些成员（参见 `net.minecraftforge.fml.common.asm.transformers.SideTransformer`）。

这一方法一般只有 Minecraft 以及 Forge 会用。Forge 会将 Mojang 混淆器剔除掉的成员用该注解标注出来。

使用这一方法前还请三思，如果你不能**100% 地确定**被注解成员只在某一端有效，那你最好不要鲁莽地使用该注解。

如果错误地使用了该注解，那么游戏实例崩溃是必然，而且崩溃报告通常让人不知所云（尤其是类转换）。

## `@NetworkCheckHandler`

虽然字面上看起来让人有些摸不着头脑，但实际上，这一注解能够帮助你访问**另一实体端**的信息。

- 语法：在你注解了 `@Mod` 的类中创建一个方法，方法名不重要，重要的是这个方法需要接受两个参数，为 `(Map<String, String>, net.minecraftforge.fml.relauncher.Side)`，并且返回值必须为 `boolean`。

在握手期间，当`实体客户端`尝试加入到`实体服务端`时，首先服务端会尝试调用注解了 `@NetworkCheckHandler` 的方法（如果有的话），并依照返回值确认是否应该放行该客户端，让其加入到服务端中，而客户端同理，也会判断自己是否应该加入到服务端中。

感谢 [Forge 社区维基](https://forge.gemwire.uk/wiki/Sides) 提供的详实信息。
